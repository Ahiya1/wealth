# Code Patterns & Conventions - Iteration 2

## Overview

This document provides copy-pasteable code patterns for Supabase integration and runtime error fixes. Every pattern includes WORKING code examples ready for builders to copy and adapt.

## Supabase Setup Patterns

### Pattern 1: Supabase CLI Installation

**When to use:** Initial project setup or adding Supabase to existing project

**Commands:**

```bash
# Install Supabase CLI as devDependency (project-local)
npm install supabase@^1.200.3 --save-dev

# Verify installation
npx supabase --version
# Expected output: supabase 1.200.3

# Initialize Supabase project structure
npx supabase init
# Creates: supabase/ directory with config.toml and migrations/
```

**Key Points:**
- Always use `npx supabase` (not global `supabase`) for consistency
- Installation adds ~50MB to node_modules
- First `supabase start` downloads ~2GB Docker images (one-time)
- Requires Docker Desktop installed and running

### Pattern 2: Supabase Configuration File

**File:** `supabase/config.toml` (auto-generated by `supabase init`, then customize)

**Complete Configuration:**

```toml
# Supabase local development configuration

project_id = "wealth-local-dev"

[api]
enabled = false
port = 54321
# Disable PostgREST API (using tRPC instead)

[db]
enabled = true
port = 5432
major_version = 15
# Core PostgreSQL database - REQUIRED

[db.pooler]
enabled = true
port = 54322
pool_mode = "transaction"
default_pool_size = 20
max_client_connections = 100
# pgBouncer for connection pooling - REQUIRED

[studio]
enabled = true
port = 54323
# Supabase Studio web GUI - RECOMMENDED

[auth]
enabled = false
port = 54324
# Disable Supabase Auth (using NextAuth)

[storage]
enabled = false
port = 54325
# Disable Storage (no file storage in MVP)

[realtime]
enabled = false
port = 54326
# Disable Realtime (no real-time features in MVP)

[functions]
enabled = false
# Disable Edge Functions (using Next.js API routes)

[analytics]
enabled = false
# Disable Analytics (not needed for local dev)
```

**Key Points:**
- Only 3 services enabled: Database, Pooler, Studio
- Reduces resource usage from ~500MB → ~300MB RAM
- Faster startup: ~60s → ~30s
- Fewer ports to manage

**Common Customizations:**

```toml
# If port 5432 conflicts with local PostgreSQL
[db]
port = 5433

# Then update DATABASE_URL accordingly
# DIRECT_URL="postgresql://postgres:postgres@localhost:5433/postgres"
```

### Pattern 3: Supabase Lifecycle Commands

**Starting Supabase:**

```bash
# Start all enabled services
npm run db:local
# OR
npx supabase start

# Expected output:
# Starting Supabase local development setup...
# Pulling Docker images...
# Starting PostgreSQL...
# Starting Pooler...
# Starting Studio...
# Supabase local development setup is running.
#
# API URL: http://localhost:54321
# DB URL: postgresql://postgres:postgres@localhost:54322/postgres
# Studio URL: http://localhost:54323
```

**Checking Status:**

```bash
npx supabase status

# Expected output:
# supabase local development setup is running.
#
# API URL: http://localhost:54321
# DB URL: postgresql://postgres:postgres@localhost:54322/postgres
# Studio URL: http://localhost:54323
# anon key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
# service_role key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Stopping Supabase:**

```bash
# Stop services (preserves data)
npm run db:stop
# OR
npx supabase stop

# Stop and remove data (clean slate)
npx supabase stop --no-backup
```

**Resetting Database:**

```bash
# Wipe database, reapply schema, reseed
npm run db:reset
# OR
npx supabase db reset && npm run db:seed
```

**Key Points:**
- `start` is idempotent (safe to run multiple times)
- `stop` preserves data in Docker volumes
- `stop --no-backup` removes all data
- `reset` useful for testing seed scripts

### Pattern 4: Environment Variable Setup

**File:** `.env.local` (create from .env.example)

**Complete Environment Configuration:**

```bash
# ============================================
# DATABASE CONFIGURATION (REQUIRED)
# ============================================

# Pooled connection for application queries (via pgBouncer)
DATABASE_URL="postgresql://postgres:postgres@localhost:54322/postgres?pgbouncer=true"

# Direct connection for migrations (bypasses pooler)
DIRECT_URL="postgresql://postgres:postgres@localhost:5432/postgres"

# ============================================
# NEXTAUTH CONFIGURATION (REQUIRED)
# ============================================

# Generate with: openssl rand -base64 32
NEXTAUTH_SECRET="Kx8F3jP9mQ7vN2wR5tY8zL1dS4gH6kJ0"

# Local development URL
NEXTAUTH_URL="http://localhost:3000"

# ============================================
# SUPABASE CONFIGURATION (OPTIONAL)
# ============================================
# Only needed for Supabase-specific features (Auth, Storage, PostgREST)
# Get these values from: npx supabase status

SUPABASE_URL="http://localhost:54321"
SUPABASE_ANON_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0"
SUPABASE_SERVICE_ROLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImV4cCI6MTk4MzgxMjk5Nn0.EGIM96RAZx35lJzdJsyH-qQwv8Hdp7fsn3W0YpN81IU"

# ============================================
# GOOGLE OAUTH (OPTIONAL)
# ============================================
# Get from: https://console.cloud.google.com/apis/credentials

GOOGLE_CLIENT_ID="your-google-client-id.apps.googleusercontent.com"
GOOGLE_CLIENT_SECRET="your-google-client-secret"

# ============================================
# PLAID CONFIGURATION (OPTIONAL)
# ============================================
# Get from: https://dashboard.plaid.com/developers/keys

PLAID_CLIENT_ID="your-plaid-client-id"
PLAID_SECRET="your-plaid-sandbox-secret"
PLAID_ENV="sandbox"

# Encryption key for Plaid access tokens
# Generate with: openssl rand -hex 32
ENCRYPTION_KEY="a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2"

# ============================================
# ANTHROPIC CONFIGURATION (OPTIONAL)
# ============================================
# Get from: https://console.anthropic.com/

ANTHROPIC_API_KEY="sk-ant-api03-..."

# ============================================
# RESEND CONFIGURATION (OPTIONAL)
# ============================================
# Get from: https://resend.com/api-keys

RESEND_API_KEY="re_..."
```

**Key Points:**
- Required: DATABASE_URL, DIRECT_URL, NEXTAUTH_SECRET, NEXTAUTH_URL
- Optional: All others (graceful degradation if missing)
- Generate secrets locally (don't share)
- Supabase keys retrieved after first `supabase start`

**Secret Generation Commands:**

```bash
# NEXTAUTH_SECRET (32-character base64)
openssl rand -base64 32
# Output: Kx8F3jP9mQ7vN2wR5tY8zL1dS4gH6kJ0

# ENCRYPTION_KEY (64-character hex)
openssl rand -hex 32
# Output: a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
```

### Pattern 5: Database Migration with Supabase

**After Supabase Setup, Push Prisma Schema:**

```bash
# 1. Start Supabase
npm run db:local

# 2. Generate Prisma client
npm run db:generate

# 3. Push schema to Supabase (development only)
npm run db:push

# Expected output:
# Environment variables loaded from .env.local
# Prisma schema loaded from prisma/schema.prisma
# Datasource "db": PostgreSQL database "postgres", schema "public" at "localhost:54322"
#
# Your database is now in sync with your Prisma schema. Done in 1.23s
```

**Alternative: Use Migrations (Production-Ready):**

```bash
# Create migration file
npm run db:migrate
# Prompts for migration name: "init"

# Applies migration and generates Prisma client
# Creates: prisma/migrations/TIMESTAMP_init/migration.sql
```

**Seeding Database:**

```bash
# Run seed script (populates default categories)
npm run db:seed

# Expected output:
# Seeding database...
# Created 15 default categories
# Seed completed successfully
```

**Verify Migration:**

```bash
# Option 1: Supabase Studio (browser)
open http://localhost:54323
# Navigate to Table Editor
# Verify all 10 tables exist: User, Account, Transaction, etc.

# Option 2: Prisma Studio (browser)
npm run db:studio
# Opens http://localhost:5555
# Verify all 10 tables visible
```

**Key Points:**
- Use `db:push` for rapid development (no migration files)
- Use `db:migrate` for production (creates migration history)
- Always generate Prisma client after schema changes
- Seed script populates default categories (required)

### Pattern 6: npm Scripts in package.json

**Add These Scripts:**

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",

    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts",

    "db:local": "supabase start",
    "db:stop": "supabase stop",
    "db:reset": "supabase db reset && npm run db:seed",
    "db:studio:supabase": "supabase start && open http://localhost:54323",

    "dev:setup": "supabase start && npm run db:push && npm run db:seed && npm run dev"
  }
}
```

**Script Usage:**

```bash
# New developer onboarding (one command)
npm run dev:setup

# Daily development
npm run db:local   # Start Supabase
npm run dev        # Start Next.js

# Database operations
npm run db:push    # Push schema changes
npm run db:seed    # Reseed data
npm run db:reset   # Nuclear option (wipe + reseed)

# Database inspection
npm run db:studio           # Prisma Studio
npm run db:studio:supabase  # Supabase Studio

# Shutdown
npm run db:stop    # Stop Supabase
```

**Key Points:**
- `dev:setup` is idempotent (safe to run multiple times)
- All database scripts require Supabase running
- Use `db:reset` sparingly (destroys all data)

## Environment Validation Patterns

### Pattern 7: Type-Safe Environment Variables

**File:** `src/lib/env.ts` (create this file)

**Complete Implementation:**

```typescript
import { z } from 'zod'

/**
 * Environment variable validation schema
 *
 * CRITICAL variables cause app to fail if missing
 * OPTIONAL variables allow graceful degradation
 */
const envSchema = z.object({
  // Node environment
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),

  // Database (CRITICAL)
  DATABASE_URL: z.string().url('DATABASE_URL must be a valid URL'),
  DIRECT_URL: z.string().url('DIRECT_URL must be a valid URL').optional(),

  // NextAuth (CRITICAL)
  NEXTAUTH_SECRET: z
    .string()
    .min(32, 'NEXTAUTH_SECRET must be at least 32 characters')
    .describe('Generate with: openssl rand -base64 32'),
  NEXTAUTH_URL: z
    .string()
    .url('NEXTAUTH_URL must be a valid URL')
    .default('http://localhost:3000'),

  // Supabase (OPTIONAL - only for Supabase-specific features)
  SUPABASE_URL: z.string().url().optional(),
  SUPABASE_ANON_KEY: z.string().optional(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().optional(),

  // Google OAuth (OPTIONAL)
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),

  // Plaid (OPTIONAL)
  PLAID_CLIENT_ID: z.string().optional(),
  PLAID_SECRET: z.string().optional(),
  PLAID_ENV: z.enum(['sandbox', 'development', 'production']).optional(),
  ENCRYPTION_KEY: z
    .string()
    .length(64, 'ENCRYPTION_KEY must be exactly 64 characters (hex)')
    .optional(),

  // Anthropic (OPTIONAL)
  ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-').optional(),

  // Resend (OPTIONAL)
  RESEND_API_KEY: z.string().startsWith('re_').optional(),
})

/**
 * Validated environment variables
 *
 * Import this instead of process.env for type safety
 */
export const env = envSchema.parse(process.env)

/**
 * Type-safe environment variable access
 */
export type Env = z.infer<typeof envSchema>
```

**Usage in Application Code:**

```typescript
// ❌ BAD: Direct process.env access (no type safety)
const databaseUrl = process.env.DATABASE_URL

// ✅ GOOD: Use validated env object
import { env } from '@/lib/env'

const databaseUrl = env.DATABASE_URL  // TypeScript knows this exists and is valid

// Conditional features based on optional variables
if (env.PLAID_CLIENT_ID && env.PLAID_SECRET) {
  // Initialize Plaid client
} else {
  // Show manual account entry form
}
```

**Key Points:**
- Fails fast on missing critical variables (app won't start)
- Provides clear error messages for misconfiguration
- TypeScript auto-completion for env variables
- Optional variables don't cause errors (graceful degradation)

### Pattern 8: Runtime Environment Validation

**File:** `src/lib/validate-env.ts` (create this file)

**Complete Implementation:**

```typescript
import { env } from './env'

/**
 * Validate environment configuration at application startup
 *
 * Checks:
 * - Critical variables exist
 * - Database connection is valid
 * - External APIs are configured (if used)
 *
 * Exits process if critical errors found
 */
export async function validateEnvironment() {
  const errors: string[] = []
  const warnings: string[] = []

  // Check database connection
  try {
    const { PrismaClient } = await import('@prisma/client')
    const prisma = new PrismaClient()
    await prisma.$connect()
    await prisma.$disconnect()
    console.log('✅ Database connection successful')
  } catch (error) {
    errors.push(`❌ Database connection failed: ${error}`)
  }

  // Check NextAuth configuration
  if (!env.NEXTAUTH_SECRET || env.NEXTAUTH_SECRET.length < 32) {
    errors.push('❌ NEXTAUTH_SECRET must be at least 32 characters')
  } else {
    console.log('✅ NextAuth configured')
  }

  // Warn about optional integrations
  if (!env.PLAID_CLIENT_ID) {
    warnings.push('⚠️  Plaid not configured (manual account entry only)')
  }

  if (!env.ANTHROPIC_API_KEY) {
    warnings.push('⚠️  Anthropic not configured (manual categorization only)')
  }

  if (!env.GOOGLE_CLIENT_ID) {
    warnings.push('⚠️  Google OAuth not configured (email/password auth only)')
  }

  // Print warnings
  warnings.forEach((warning) => console.log(warning))

  // Exit if critical errors
  if (errors.length > 0) {
    console.error('\n❌ Environment validation failed:\n')
    errors.forEach((error) => console.error(error))
    console.error('\nPlease check your .env.local file\n')
    process.exit(1)
  }

  console.log('✅ Environment validation passed\n')
}
```

**Usage in Application Startup:**

```typescript
// src/app/layout.tsx or instrumentation.ts
import { validateEnvironment } from '@/lib/validate-env'

// Run validation on server startup
if (process.env.NODE_ENV === 'development') {
  validateEnvironment().catch((error) => {
    console.error('Environment validation error:', error)
    process.exit(1)
  })
}
```

**Key Points:**
- Runs once at application startup
- Tests actual database connection (not just URL format)
- Warns about missing optional features
- Fails fast with clear error messages
- Only runs in development (skip in production build)

## Error Handling Patterns

### Pattern 9: React Error Boundary

**File:** `src/components/ErrorBoundary.tsx` (create this file)

**Complete Implementation:**

```typescript
'use client'

import { Component, type ReactNode } from 'react'
import { AlertTriangle } from 'lucide-react'

interface ErrorBoundaryProps {
  children: ReactNode
  fallback?: ReactNode
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
}

/**
 * Error Boundary Component
 *
 * Catches React component errors and displays fallback UI
 * Prevents entire app from crashing due to single component error
 *
 * Usage:
 * <ErrorBoundary fallback={<CustomError />}>
 *   <ComponentThatMightError />
 * </ErrorBoundary>
 */
export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    // Update state so next render shows fallback UI
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log error to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('ErrorBoundary caught error:', error, errorInfo)
    }

    // Call optional error handler
    this.props.onError?.(error, errorInfo)

    // TODO: Send to error tracking service (Sentry, LogRocket, etc.)
  }

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback
      }

      // Default fallback UI
      return (
        <div className="flex min-h-[400px] flex-col items-center justify-center rounded-lg border border-destructive/50 bg-destructive/10 p-8 text-center">
          <AlertTriangle className="mb-4 h-12 w-12 text-destructive" />
          <h2 className="mb-2 text-xl font-semibold">Something went wrong</h2>
          <p className="mb-4 text-sm text-muted-foreground">
            {this.state.error?.message || 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90"
          >
            Try again
          </button>
        </div>
      )
    }

    return this.props.children
  }
}
```

**Usage Examples:**

```typescript
// Wrap entire page
export default function DashboardPage() {
  return (
    <ErrorBoundary>
      <Dashboard />
    </ErrorBoundary>
  )
}

// Wrap specific component
<ErrorBoundary fallback={<div>Chart failed to load</div>}>
  <AnalyticsChart data={data} />
</ErrorBoundary>

// With custom error handler
<ErrorBoundary
  onError={(error, errorInfo) => {
    // Send to Sentry, LogRocket, etc.
    console.error('Component error:', error, errorInfo)
  }}
>
  <CriticalComponent />
</ErrorBoundary>
```

**Key Points:**
- Prevents entire app crash from single component error
- Shows user-friendly error message
- Provides "Try again" button to recover
- Logs errors to console in development
- Can be customized with fallback prop

### Pattern 10: tRPC Error Handling

**Server-Side Error Handling (tRPC Procedures):**

```typescript
// src/server/api/routers/accounts.router.ts
import { TRPCError } from '@trpc/server'
import { z } from 'zod'

export const accountsRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      z.object({
        name: z.string().min(1),
        type: z.enum(['CHECKING', 'SAVINGS', 'CREDIT', 'INVESTMENT']),
        balance: z.number(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        const account = await ctx.prisma.account.create({
          data: {
            ...input,
            userId: ctx.session.user.id,
          },
        })

        return account
      } catch (error) {
        // Log error for debugging
        console.error('Failed to create account:', error)

        // Throw user-friendly error
        if (error instanceof Error && error.message.includes('Unique constraint')) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'An account with this name already exists',
          })
        }

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to create account. Please try again.',
        })
      }
    }),
})
```

**Client-Side Error Handling (React Components):**

```typescript
// src/app/(dashboard)/accounts/page.tsx
'use client'

import { api } from '@/lib/trpc'
import { useToast } from '@/components/ui/use-toast'

export function CreateAccountForm() {
  const { toast } = useToast()
  const createAccount = api.accounts.create.useMutation({
    onSuccess: (account) => {
      toast({
        title: 'Account created',
        description: `${account.name} has been added to your accounts.`,
      })
    },
    onError: (error) => {
      toast({
        variant: 'destructive',
        title: 'Failed to create account',
        description: error.message,
      })
    },
  })

  const handleSubmit = async (data: AccountFormData) => {
    try {
      await createAccount.mutateAsync(data)
    } catch (error) {
      // Error already handled in onError callback
      console.error('Create account error:', error)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={createAccount.isLoading}>
        {createAccount.isLoading ? 'Creating...' : 'Create Account'}
      </button>
    </form>
  )
}
```

**Key Points:**
- Server: Throw TRPCError with appropriate code and message
- Client: Handle errors in onError callback
- Show user-friendly error messages (not stack traces)
- Log errors to console for debugging
- Disable submit button while loading

### Pattern 11: Database Error Handling

**Prisma Error Handling:**

```typescript
import { Prisma } from '@prisma/client'
import { TRPCError } from '@trpc/server'

async function createTransaction(data: TransactionData) {
  try {
    return await prisma.transaction.create({ data })
  } catch (error) {
    // Prisma known errors
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          // Unique constraint violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'A transaction with these details already exists',
          })

        case 'P2003':
          // Foreign key constraint violation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid account or category ID',
          })

        case 'P2025':
          // Record not found
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Transaction not found',
          })

        default:
          console.error('Prisma error:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database operation failed',
          })
      }
    }

    // Prisma connection errors
    if (error instanceof Prisma.PrismaClientInitializationError) {
      console.error('Database connection failed:', error)
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Unable to connect to database. Please check your configuration.',
      })
    }

    // Unknown errors
    console.error('Unexpected error:', error)
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred',
    })
  }
}
```

**Key Points:**
- Handle specific Prisma error codes with user-friendly messages
- Log errors for debugging
- Don't expose database internals to users
- Provide actionable error messages

## Hydration Fix Patterns

### Pattern 12: Client-Only Rendering

**Problem:** Date/time displays cause hydration mismatches

**Solution Pattern:**

```typescript
'use client'

import { useEffect, useState } from 'react'

/**
 * Client-Only Wrapper Component
 *
 * Prevents hydration mismatches for client-specific content
 * (dates, times, random values, browser APIs)
 */
export function ClientOnly({ children }: { children: React.ReactNode }) {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  // Server renders null, client renders children
  if (!mounted) return null

  return <>{children}</>
}
```

**Usage:**

```typescript
// Component with hydration issue
export function TransactionDate({ date }: { date: Date }) {
  return (
    <ClientOnly>
      <time>{date.toLocaleDateString()}</time>
    </ClientOnly>
  )
}

// Dashboard with client-specific content
export function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <ClientOnly>
        <UserGreeting />  {/* Uses current time */}
        <OnlineStatus />  {/* Uses browser API */}
      </ClientOnly>
    </div>
  )
}
```

**Key Points:**
- Server renders null, client renders content
- Prevents hydration mismatch warnings
- Slight flicker on first load (acceptable trade-off)
- Use sparingly (prefer consistent server/client rendering)

### Pattern 13: Consistent Date Formatting

**Problem:** Server and client format dates differently (timezone, locale)

**Solution Pattern:**

```typescript
// src/lib/format.ts
import { format as dateFnsFormat, formatDistance, parseISO } from 'date-fns'

/**
 * Consistent date formatting utilities
 *
 * Same output on server and client (no hydration mismatch)
 */

/**
 * Format date consistently (ISO 8601)
 * Example: "2024-10-01"
 */
export function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? parseISO(date) : date
  return dateFnsFormat(d, 'yyyy-MM-dd')
}

/**
 * Format date for display
 * Example: "Oct 1, 2024"
 */
export function formatDateDisplay(date: Date | string): string {
  const d = typeof date === 'string' ? parseISO(date) : date
  return dateFnsFormat(d, 'MMM d, yyyy')
}

/**
 * Format date and time
 * Example: "Oct 1, 2024 3:45 PM"
 */
export function formatDateTime(date: Date | string): string {
  const d = typeof date === 'string' ? parseISO(date) : date
  return dateFnsFormat(d, 'MMM d, yyyy h:mm a')
}

/**
 * Relative time (client-only)
 * Example: "2 hours ago"
 */
export function formatRelativeTime(date: Date | string): string {
  const d = typeof date === 'string' ? parseISO(date) : date
  return formatDistance(d, new Date(), { addSuffix: true })
}

/**
 * Format currency consistently
 * Example: "$1,234.56"
 */
export function formatCurrency(amount: number | string): string {
  const num = typeof amount === 'string' ? parseFloat(amount) : amount
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(num)
}
```

**Usage:**

```typescript
import { formatDate, formatCurrency } from '@/lib/format'

// ❌ BAD: Different output on server/client
<time>{new Date(transaction.date).toLocaleDateString()}</time>

// ✅ GOOD: Consistent output
<time>{formatDate(transaction.date)}</time>

// ❌ BAD: Different currency formatting
<span>${transaction.amount.toFixed(2)}</span>

// ✅ GOOD: Consistent formatting
<span>{formatCurrency(transaction.amount)}</span>
```

**Key Points:**
- Use date-fns for consistent date formatting
- Always use same format string on server and client
- Avoid toLocaleDateString() (locale-dependent)
- Wrap relative times in ClientOnly component

### Pattern 14: Fixing "use client" Directive Errors

**Problem:** Using hooks in server components

**Solution Pattern:**

```typescript
// ❌ BAD: Server component trying to use client hook
export default function DashboardPage() {
  const [count, setCount] = useState(0)  // Error: useState in server component
  return <div>{count}</div>
}

// ✅ GOOD: Add 'use client' directive
'use client'

export default function DashboardPage() {
  const [count, setCount] = useState(0)  // Works!
  return <div>{count}</div>
}

// ✅ BETTER: Extract client component
// ClientCounter.tsx
'use client'

export function ClientCounter() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(count + 1)}>{count}</button>
}

// DashboardPage.tsx (stays server component)
export default function DashboardPage() {
  return (
    <div>
      <h1>Dashboard</h1>
      <ClientCounter />  {/* Client component */}
    </div>
  )
}
```

**Key Points:**
- Add 'use client' to components using hooks (useState, useEffect, etc.)
- Add 'use client' to components using browser APIs (localStorage, window, etc.)
- Prefer extracting client components (keeps server components server-side)
- 'use client' must be first line of file (before imports)

## Testing Patterns

### Pattern 15: Database Testing

**Test Database Connection:**

```typescript
// tests/db-connection.test.ts
import { describe, it, expect } from 'vitest'
import { prisma } from '@/lib/prisma'

describe('Database Connection', () => {
  it('should connect to database', async () => {
    await expect(prisma.$connect()).resolves.not.toThrow()
    await prisma.$disconnect()
  })

  it('should query database', async () => {
    const categories = await prisma.category.findMany({ take: 1 })
    expect(categories).toBeDefined()
  })
})
```

**Run Tests:**

```bash
# Ensure Supabase is running
npm run db:local

# Run tests
npm test
```

### Pattern 16: Manual Testing Checklist

**Complete Testing Flow:**

```bash
# 1. Clean Environment
npm run db:reset
# Wipes database, reapplies schema, reseeds

# 2. Start Application
npm run dev
# Opens http://localhost:3000

# 3. Test Authentication
# - Navigate to /signup
# - Create test user: test@example.com / password123
# - Should redirect to /dashboard
# - Verify session persists after refresh

# 4. Test Dashboard
# - Dashboard should load without errors
# - Check browser console (should be clean)
# - Verify charts render (even with no data)

# 5. Test Account Creation
# - Navigate to /accounts
# - Click "Add Account"
# - Fill form: "Checking Account", $1000
# - Submit
# - Should appear in account list

# 6. Test Transaction Creation
# - Navigate to /transactions
# - Click "Add Transaction"
# - Fill form: Amount $50, Category "Groceries"
# - Submit
# - Should appear in transaction list

# 7. Test Budget Creation
# - Navigate to /budgets
# - Click "Create Budget"
# - Select category "Groceries", amount $500
# - Submit
# - Should show budget card with progress

# 8. Test Goal Creation
# - Navigate to /goals
# - Click "Create Goal"
# - Enter name "Emergency Fund", target $10000
# - Submit
# - Should show goal card

# 9. Test Analytics
# - Navigate to /analytics
# - Verify charts render (even with limited data)
# - Test date range selector

# 10. Test Sign Out
# - Click user menu
# - Click "Sign Out"
# - Should redirect to landing page
# - Try accessing /dashboard (should redirect to /signin)
```

## Common Runtime Error Fixes

### Fix 1: "DATABASE_URL environment variable is not set"

**Error:**
```
Error: DATABASE_URL environment variable is not set
```

**Fix:**
```bash
# 1. Ensure .env.local exists
cp .env.example .env.local

# 2. Add DATABASE_URL
echo 'DATABASE_URL="postgresql://postgres:postgres@localhost:54322/postgres?pgbouncer=true"' >> .env.local

# 3. Restart dev server
npm run dev
```

### Fix 2: "Can't reach database server"

**Error:**
```
PrismaClientInitializationError: Can't reach database server at `localhost:54322`
```

**Fix:**
```bash
# 1. Check if Supabase is running
npx supabase status
# If not running, start it
npm run db:local

# 2. Verify DATABASE_URL is correct
echo $DATABASE_URL
# Should be: postgresql://postgres:postgres@localhost:54322/postgres?pgbouncer=true

# 3. Test connection
npm run db:push
```

### Fix 3: "NEXTAUTH_SECRET is required"

**Error:**
```
Error: NEXTAUTH_SECRET environment variable must be set
```

**Fix:**
```bash
# Generate secret
NEXTAUTH_SECRET=$(openssl rand -base64 32)

# Add to .env.local
echo "NEXTAUTH_SECRET=\"$NEXTAUTH_SECRET\"" >> .env.local

# Restart dev server
npm run dev
```

### Fix 4: "Hydration failed"

**Error:**
```
Warning: Text content did not match. Server: "..." Client: "..."
Error: Hydration failed because the initial UI does not match
```

**Fix:**
Wrap dynamic content in ClientOnly component (see Pattern 12)

```typescript
// Before (causes hydration error)
<time>{new Date().toLocaleString()}</time>

// After (fixed)
<ClientOnly>
  <time>{new Date().toLocaleString()}</time>
</ClientOnly>
```

### Fix 5: "Table does not exist"

**Error:**
```
PrismaClientKnownRequestError: Table 'public.User' does not exist
```

**Fix:**
```bash
# Push schema to database
npm run db:push

# If that fails, reset database
npm run db:reset
```

## Summary

**Key Patterns Implemented:**
1. Supabase CLI installation and initialization
2. Configuration file customization (disable unused services)
3. Environment variable setup with validation
4. Database migration and seeding
5. npm scripts for development workflow
6. Error boundaries for React components
7. tRPC error handling (server and client)
8. Hydration fix patterns (ClientOnly, consistent formatting)
9. Database testing patterns
10. Common runtime error fixes

**All Code is Production-Ready:**
- Copy-paste directly into project
- No pseudocode or placeholders
- Tested patterns from exploration phase
- Includes error handling and edge cases

**Builders: Use These Patterns**
- Reference this document for all implementation
- Copy code examples verbatim
- Adapt only where noted (file paths, specific values)
- Test each pattern after implementation

---

**Document Version:** 1.0
**Last Updated:** 2025-10-01
